#!/usr/bin/ruby
#
#  This script will pull tests to complete from the Beanstalk Queue,
# where they will be found in JSON form, and executes them.
#
#
#  TODO: Command line parsing:
#
#           1.  set failure count 3 in a row, for example.
#
#           2.  enable/disable logging.
#
#           3.  Specify server name/port for the beanstalk queue.
#
#
# Steve
# --
#



require 'beanstalk-client'
require 'json';




#
# Implementation of our protocol tests.
#
require 'tests/ftp'
require 'tests/http'
require 'tests/https'
require 'tests/jabber'
require 'tests/ldap'
require 'tests/ping'
require 'tests/rsync'
require 'tests/smtp'
require 'tests/ssh'





#
#  TODO
#
#    Use the mauve-library to clear the specified alert
#
def clear_alert( hash )
  puts "CLEARING ALERT: #{hash}"
end


#
# TODO
#
#    Use the mauve-library to raise the specified alert
#
def raise_alert( hash )
  puts "Raising ALERT: #{hash}"
end






#
# Connect to the queue server
#
beanstalk = Beanstalk::Pool.new(['localhost:11300'])




#
# Run until we're killed
#
loop do

  puts "\n\nWaiting for job.."


  #
  #  Find the next job.
  #
  #  TODO:
  #    1.  Reserve with a timeout
  #
  #    2.  Send a heartbeat so that we know this script is still running
  #
  job = beanstalk.reserve()
  puts "Job acquired: #{Time.new.inspect}"


  #
  #  Parse the JSON of the job body.
  #
  json = job.body
  hash = JSON.parse( json )

  #
  #  Output the details.
  #
  puts "JOB: #{job.id}"
  puts "Type of test is #{hash['test_type']}"
  hash.keys.each do |key|
    puts "\t#{key} => #{hash[key]}"
  end


  #
  #  Given the test-type of "YYY" we'll call the method "YYY_test", which
  # we assume comes from one of the files beneath ./tests/
  #
  test   = hash['test_type']
  method = "#{test}_test".to_sym

  #
  # If it succeeds.
  #
  begin

    success = false
    count   = 0

    #
    #  We'll run no more than MAX times.
    #
    #  We stop the execution on a single success.
    #
    while ( ( count < 5 ) && ( success == false ) )
      if ( send( method, hash ) )
        clear_alert(hash)
        success= true
      end
      count += 1
    end

    #
    #  If we didn't succeed on any of the attempts raise the alert.
    #
    if ( ! success )
      raise_alert( hash )
    end

  rescue => ex
    puts "Exception: #{ex}"
  ensure
    #
    #  Delete the job - either we received an error, in which case
    # we should remove it to avoid picking it up again, or we handled
    # it successfully so it should be removed.
    #
    job.delete
  end
end


