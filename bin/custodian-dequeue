#!/usr/bin/ruby1.8 -Ilib/ -I../lib/
#
# NAME
#  custodian-dequeue - Pull network tests from a queue and execute them in series.
#
# SYNOPSIS
#  custodian-dequeue  [ -h | --help ]
#                     [ -m | --manual]
#                     [ -f | --fail ]
#                     [ -l | --logfile FILE]
#                     [ -S | --server 1.2.3.4:123 ]
#                     [ -s | --single ]
#                     [ -v | --verbose ]
#
# OPTIONS
#
#  -h, --help          Show a help message, and exit.
#
#  -m, --manual        Show this manual, and exit.
#
#  -l, --logfile       Specify the path to the logfile to run.
#
#  -S, --server        Specify the host:port for the beanstalkd queue.
#
#  -s, --single        Run a single test and exit.  Don't poll the queue for more.
#
#  -f, --fail          Run tests but stop the first time we see a fail.
#
#  -v, --verbose       Be noisy.
#
#
# ABOUT
#
#  This tool is designed to pull network/protocol-tests from a beanstalkd server and execute
# them, in series.
#
#  The tests are created, via custodian-enqueue, by parsing a configuration
# file largely compatible with that used for our obsolete sentinel tool.
#
#  The results of the testing will be sent to a mauvealert server.
#
#
# AUTHOR
#
#  Steve Kemp  <steve@bytemark.co.uk>
#


#
# Standard modules
#
require 'getoptlong'


#
# Our code.
#
require 'custodian/settings.rb'
require 'custodian/worker.rb'




#
#  Entry-point to our code.
#
if __FILE__ == $0 then

  $help    = false
  $manual  = false

  #
  #  The beanstalkd server address, and logfile.
  #
  settings = Custodian::Settings.instance()
  $SERVER  = settings.queue_server
  $LOGFILE = settings.log_file

  begin
    opts = GetoptLong.new(
                          [ "--help",    "-h", GetoptLong::NO_ARGUMENT ],
                          [ "--manual",  "-m", GetoptLong::NO_ARGUMENT ],
                          [ "--fail",    "-f", GetoptLong::NO_ARGUMENT  ],
                          [ "--logfile", "-l", GetoptLong::REQUIRED_ARGUMENT ],
                          [ "--repeat",  "-r", GetoptLong::REQUIRED_ARGUMENT ],
                          [ "--server",  "-S", GetoptLong::REQUIRED_ARGUMENT ],
                          [ "--single",  "-s", GetoptLong::NO_ARGUMENT ],
                          [ "--verbose", "-v", GetoptLong::NO_ARGUMENT ]
                          )
    opts.each do |opt, arg|
      case opt
      when "--verbose" then
          ENV["VERBOSE"] = "1"
      when "--logfile" then
          $LOGFILE = arg
      when "--repeat" then
          ENV["REPEAT"] = arg
      when "--server" then
          $SERVER = arg
      when "--single" then
          ENV["SINGLE"] = "1"
      when "--fail" then
          ENV["FAIL"] = "1"
      when "--help" then
          $help = true
      when "--manual" then
          $manual = true
      end
    end
  rescue StandardError => ex
    puts "Option parsing failed: #{ex.to_s}"
    exit
  end



  #
  # CAUTION! Here be quality kode.
  #
  if $manual or $help

    # Open the file, stripping the shebang line
    lines = File.open(__FILE__){|fh| fh.readlines}[1..-1]

    found_synopsis = false

    lines.each do |line|

      line.chomp!
      break if line.empty?

      if $help and !found_synopsis
        found_synopsis = (line =~ /^#\s+SYNOPSIS\s*$/)
        next
      end

      puts line[2..-1].to_s

      break if $help and found_synopsis and line =~ /^#\s*$/

    end

    exit 0
  end

  #
  #  Create the object
  #
  worker = Custodian::Worker.new( $SERVER, $LOGFILE )


  #
  #  Single step?
  #
  if ( ENV['SINGLE'] )
    worker.process_single_job()
    exit(0)
  end

  #
  #  Run until we see a failure?
  #
  if ( ENV['FAIL'] )
    worker.process_until_fail()
    exit(0)
  end

  #
  #  Otherwise loop indefinitely
  #
  worker.run!

end
